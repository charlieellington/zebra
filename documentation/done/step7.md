Great. I'll audit the Zebra repo for production readiness, remove unused template code, and develop a final build plan optimised for Vercel. I'll also ensure responsive accordions, tooltips, accessibility, performance, and layout behaviour are all in line with your detailed notes.

I'll get back to you with a complete Markdown checklist for production preparation shortly.

Final Stage Production Build Plan for Zebra Design Site
=======================================================

1\. Codebase Cleanup and Template Removal
-----------------------------------------

-   **Purge template leftovers:** Remove any unused sections and files inherited from the Lume Studio template. For example, delete the `FullVersionSection` component and any related page (such as a `/full-version` route) that was part of the template's demo. This content (e.g. "Full Version Coming Soon!" placeholder text) is not needed for Zebra Design's site.

-   **Clean up imports and references:** Scan through the code (especially the homepage `page.tsx`) and remove imports of components that have been eliminated. For instance, the template's **Testimonials** and **ContactSection** were slated for removal, so their imports (and usage in the JSX) should be deleted to avoid bundling dead code. This keeps the project lean and ensures old sections (Team, Contact, etc.) don't accidentally render.

-   **Update project metadata:** Replace any remaining template identifiers with Zebra Design info. In **package.json**, change the `"name"` from `"lume-studio"` to something like `"zebra-design-site"` and update the `"repository"` URL if it still points to the template repo. This is a housekeeping step so the project is correctly labeled and doesn't reference the old template or Kohi Studio.

-   **Remove unused assets and code:** Delete any CSS, images, or libraries that were included for template features you've removed. For example, if there were images for team members or logos from the template that are not used in the Zebra site, remove them. Likewise, eliminate any leftover configuration (e.g., template-specific settings or environment variables like `NEXT_PUBLIC_WAIT_LIST_API` if it was part of the template's newsletter form) that no longer apply. Unused code can confuse future maintenance and might even introduce security risks, so it's best to clear it out now.

-   **Finalize branding consistency:** Do one more pass to ensure all text/content reflects Zebra Design's branding. Double-check there are no old names (like "Lume Studio") or placeholder text hiding in the UI or metadata (such as HTML `<title>` or `<meta>` description). This includes checking the favicon and logo assets -- make sure the favicon is the Zebra Design logo, not the template's. Removing template code goes hand-in-hand with removing any template branding.

2\. Responsive Behavior & Interactive UI Tweaks
-----------------------------------------------

-   **Mobile accordion defaults:** On **small screens**, ensure that all accordion-style sections are collapsed by default. Sections like **Process**, **Pain Points**, **FAQs**, **Pricing**, and **Projects** should render in a closed state on mobile so that users see headers and can tap to expand as needed. (Any section that isn't an accordion, such as a static "Credo" or intro statement, can remain fully visible.) This way, a first-time mobile visitor isn't overwhelmed by lengthy expanded content and can navigate the page easily.

-   **Desktop accordion defaults:** On **large screens**, adjust the default state per section requirements. The **Process** section, for instance, should display all steps expanded on desktop (since there's room to show all content at once) to clearly illustrate the end-to-end process. In contrast, other accordion sections like Pain Points, FAQs, and Projects should remain collapsed by default on desktop, only expanding when the user clicks. This prevents an overly long page on load, while still allowing interested users to open items interactively. For the **Pricing** section on desktop, decide on a consistent approach -- a common pattern is to have one pricing tier (e.g. the first tier) expanded by default to draw attention, while the rest are closed. Ensure the default expanded tier (if any) is visually highlighted, or opt to keep all tiers closed initially for uniformity, based on what looks best.

-   **"Quick Wins" tooltips on touch devices:** Refine the behavior of any hover-reliant tooltips (like the Quick Wins icons with explanatory text). On desktop, these can continue to appear on hover as implemented. On mobile/touch, however, pure hover doesn't work -- we need a tap interaction or an alternate design. Leverage Radix UI's flexibility here: you can wrap tooltips with a `TooltipProvider` and adjust the delay so that a tap shows the tooltip for a longer time, or switch to a more touch-friendly popover (which opens on tap and requires an explicit close). If time is short or the tooltip component isn't reliable on mobile, a simple fallback is to **always show the brief description text on mobile** (for example, using a Tailwind utility to hide the text on `md` screens and up). This way, each icon's benefit text is immediately visible under the icon when viewed on a phone, removing any ambiguity for touch users. The goal is to ensure mobile visitors get the same information without frustration.

-   **Breakpoint testing and layout polish:** Manually test the site at various widths (e.g. ~320px, 640px, 768px, 1024px, 1440px) to cover common breakpoints. Confirm that the layout switches as expected -- for example, if the Process section uses a completely separate markup or component for mobile vs desktop (as a workaround to have different default states or layouts), verify that the correct version is shown at each breakpoint. Look for any odd spacing issues in between breakpoints, such as a two-column layout that doesn't quite collapse yet on a small tablet, causing a squished look. Adjust Tailwind responsive classes or add custom breakpoints if needed to smooth these transitions. Consistency is key: if you duplicated content for different screen sizes (not ideal, but sometimes done for simplicity), ensure both versions have identical text and styling so the user never notices a difference when resizing.

-   **Interactive component review:** Go through all interactive elements one more time in the final build context. This includes the nav menu (especially if it's a hamburger menu on mobile), accordion toggles, tab switches, and any buttons with state. Make sure that state resets appropriately when moving between screen sizes (for example, if an accordion was opened on mobile and the user then rotates to landscape or a larger screen, the section might switch to a different component -- ensure no stuck "open" state or duplicate content occurs). Check that no accordion accidentally auto-expands on page load except where intended. Also verify any **sticky elements** (like a sticky header or a floating CTA) function well: on mobile Safari, position: sticky can be finicky, so confirm that a sticky header doesn't cover content or that a fixed CTA bar doesn't overlap important buttons. Tweak z-index or conditional rendering as needed to refine this.

3\. Cross-Browser & Accessibility Testing
-----------------------------------------

-   **Multi-browser validation:** Test the site in a few different browsers and devices to catch any engine-specific issues. On desktop, use Chrome, Firefox, and Safari. On mobile, test on an iPhone (Safari) and an Android device if possible (Chrome). Ensure the visual design is consistent (fonts load, flexbox grids work the same, etc.) and that all interactive elements respond. Pay attention to iOS Safari's handling of focus and hover: for instance, tapping a tooltip icon in iOS might require two taps if the first tap only brings focus. If you find odd behavior, you might need to adjust the interaction (e.g., use a click toggle for tooltips on touch devices). Also verify that any CSS hacks or polyfills behave (Safari often has quirks with modern CSS like `backdrop-filter` or flex gaps -- make sure nothing is broken in those browsers).

-   **Keyboard navigation and focus states:** Conduct an **accessibility audit** focusing on keyboard use and screen readers. Try to navigate the entire page with the keyboard alone (Tab, Shift+Tab, Enter/Space to activate). All interactive controls should be reachable in a logical order. For example, the accordion headers should receive focus and show a visible focus outline when tabbed to. Using Radix UI components for accordions and toggles helps, as they manage ARIA attributes like `aria-expanded` and `aria-controls` for you, which is important for assistive tech. Ensure that as you open an accordion with the keyboard, the focus isn't lost (focus should ideally move into the panel or remain on the header). If any custom components don't show focus rings (perhaps because of custom styling), add a CSS focus style or utilize Tailwind's focus utilities to make it obvious which element is active.

-   **ARIA labels and roles:** Audit the HTML output for accessibility attributes. All images and icons need alt text or aria labels as appropriate. For example, the quick win icons could have `aria-label="Speed benefit"` if they're interactive, or an `alt="Speed icon"` if they are images. Decorative images can use `alt=""` to be ignored by screen readers. Ensure accordion buttons have proper roles (Radix's Accordion trigger should be a `<button>` with `aria-expanded` state -- verify this in the DOM). If you have any custom interactive element (like a pricing toggle that isn't a standard input), ensure it has `role="button"` and keyboard handlers so that it's operable via Enter/Space. Use a screen reader (VoiceOver on Mac or NVDA/JAWS on PC) to do a quick run-through and see if the content makes sense when read aloud.

-   **Color contrast check:** With the new Zebra Design color scheme, run a contrast test on text vs background. Particularly check light text on colored backgrounds or vice versa. For instance, if you have pink (#E7BDD7) or coral (#FDA7A0) accents on white, these should still meet the contrast ratio guidelines for headings or body text. Tools like WebAIM's contrast checker can be used. Adjust colors if needed (darken them slightly) or increase font weight for better readability. Also ensure link text or buttons have adequate contrast in both regular and hover states (e.g., a hover darkening should not make text illegible). Accessibility is part of production readiness -- a site that is hard to read for some users can be seen as not truly "done."

-   **Content consistency and audit:** Do a final review of all text content for clarity and consistency. Remove any placeholder or lorem ipsum text that might still be lingering. Make sure all calls-to-action and section descriptions are final. This includes things like meta titles/descriptions (the site's `<head>` should have the correct Zebra Design title and description as provided in the content brief), as well as open graph tags if set. From an accessibility perspective, ensure headings are used in a logical order (e.g., an `<h2>` for each main section like "About", "Services", etc., and maybe `<h3>` for subsections). This structural check helps both SEO and screen readers. If the contact form was removed, ensure any menu link to "Contact" is either removed or repurposed (e.g., maybe it now scrolls to a footer or is replaced by a mailto link). The site should feel cohesive and polished, with no vestiges of template content.

4\. Performance Optimization & Build Verification
-------------------------------------------------

-   **Optimize images with Next.js:** Go through every image and ensure it's using Next's optimized image component if appropriate. The Next.js `<Image>` component will automatically create responsive versions and serve modern formats like WebP for better performance. Check that all `<Image>` elements have defined `width` and `height` (or `fill` with parent relative sizing) to avoid layout shifts. Also, verify that any large images (hero background, project screenshots, etc.) are compressed. Ideally, run them through an image optimizer to reduce file size. This will keep the page lightweight for users.

-   **Remove or split any heavy scripts:** Since this is mostly a static site, there shouldn't be many third-party scripts, but double-check if anything like analytics or embed codes are included. If you have added something like a YouTube embed or a chat widget, consider using Next's dynamic import with `ssr:false` or loading such scripts on interaction to avoid slowing initial load. In general, eliminate any JavaScript not strictly necessary for the page. Next.js by default will tree-shake and code-split, meaning unused code won't be included in the final bundle. However, that only works if the code isn't imported. So make sure you're not importing modules or components that you don't actually use. This ties back to the code cleanup step -- by removing unused imports (like the template sections), you let Next's build optimize the bundle size effectively.

-   **Run a production build locally:** Before deploying, run `pnpm build` (or `npm run build`) to generate the production optimized build. This will catch any TypeScript errors or build-time issues. For example, if you removed a component but forgot to remove its import, TypeScript/ESLint might throw an error or warning about an unused variable. Fix all such errors by fully removing or adjusting the code. A clean build is crucial. Also, check the console output for any warnings -- Next might warn about large images or any deprecated usage. Resolve those if possible. Once the build succeeds, start the app locally with `pnpm start` to serve the compiled version. Do a quick regression test on this served version to ensure everything still works (sometimes differences between dev mode and production mode -- such as hydration timing -- can surface issues, so it's worth a look).

-   **Performance testing:** With the local production build or a staged deployment, run performance tests. Use Lighthouse (in Chrome DevTools) to get a performance score and see if any improvements can be made. Given this is a static one-page site, you should aim for a very high performance score. Lighthouse might flag things like large images (which you would address by the optimizations above) or unused CSS (Tailwind should be purging unused styles by default in production). If you see opportunities like "Reduce unused JavaScript," make sure no big library is inadvertently bundled. You could use Next.js's **Bundle Analyzer** (`next build --analyze`) to inspect the bundle if needed -- but if the template was well-optimized, this may not be an issue. Also check the **Core Web Vitals** metrics (LCP, CLS, etc.) in Lighthouse; those are important for SEO and user experience. Small tweaks like preloading key resources or fine-tuning image loading priority can help if needed.

-   **Verify Motion.dev animations and other effects:** The site uses Motion.dev (and possibly Framer Motion or similar) for animations. Ensure that all animations still trigger correctly in the production build. Open the site and scroll through -- elements should reveal or animate as intended. If you removed certain sections that the ScrollView component was targeting, make sure you didn't leave an array of targets that now has a null (which could cause an error). Check the browser console for any errors related to animations or any other scripts. Fix any that appear. Also, confirm that the animations aren't causing performance jank; they should be running via `requestAnimationFrame` (which Motion.dev would handle) and not blocking the main thread. If any animation seems too heavy on mobile (causing stutters), consider simplifying or disabling it for that platform. The final build should be not just functionally correct, but smooth.

5\. Security Audit and Best Practices
-------------------------------------

-   **Dependency audit:** Make sure all your dependencies are up to date, especially if the template is a few months old. Run `pnpm update` for minor/patch upgrades and check `pnpm audit` for known vulnerabilities. Address any high-severity issues by upgrading the package or applying patches. For example, if a Tailwind or Radix UI subdependency had a security fix, pulling in the latest version ensures you're not deploying a site with a known hole. Keeping the dependency tree fresh is an easy win for security.

-   **Secret management:** Confirm that no secret keys or sensitive info are in the frontend code. Typically, a static site shouldn't have secrets (API keys for third-party services should be stored in environment variables and only exposed if absolutely necessary). Review the `.env` or environment variables used. Remove any that aren't needed. For any necessary runtime keys (like an API endpoint URL), ensure they are prefixed with `NEXT_PUBLIC_` only if they need to be used in client-side code. Others should remain purely on the server (or better yet, not needed at all for a static site). The rule is: if it's in your GitHub repo or in the client bundle, assume it's public. So don't include anything there that shouldn't be public.

-   **Disable X-Powered-By header:** In production, it's a good practice to hide the framework signature. Next.js by default sends an `X-Powered-By: Next.js` header. It doesn't expose a vulnerability by itself, but it's information disclosure that can be avoided. To turn it off, add `poweredByHeader: false` in your Next.js config. This way, the response headers from your site won't advertise that it's a Next.js application. It's a small tweak, but part of "security through obscurity" best practices -- while not a security feature per se, it removes a potential fingerprint.

-   **Apply security headers and SEO meta:** Consider setting HTTP security headers in Next if not already done. Vercel allows setting headers either in `next.config.js` or a `vercel.json`. Important ones to think about: `Content-Security-Policy` (CSP) to restrict sources of scripts/images (this can be complex, and if you're not loading external scripts it might not be necessary), `Strict-Transport-Security` (HSTS) to enforce HTTPS, `Referrer-Policy` to control referrer info leakage, and `Permissions-Policy` to restrict certain browser features. None of these are absolutely required for a simple static site, but they add defense-in-depth. At minimum, ensure the site is served on HTTPS (Vercel does this by default) and that all external resources (fonts, etc.) use HTTPS. Also verify your **robots.txt** and **sitemap.xml** if any -- since we're about to launch, we want to be indexable (unless intentionally not). Make sure no meta tag or robots setting is accidentally telling search engines not to index.

-   **Form and input handling:** If the site has any forms (contact form, email signup), ensure they are secure. It sounds like the contact form might have been removed; but if there's a newsletter signup or similar (for example, the template's waitlist form), make sure it's wired to the correct backend endpoint over HTTPS and doesn't expose any API keys. Implement basic validation both client-side (to prompt the user) and server-side (to actually enforce rules). If you accept any user input, even something as simple as an email, consider using a CAPTCHA or honeypot to prevent spam. Additionally, sanitize any displayed user input (though in a static site there may be none). Since Zebra Design site is mostly static content, the surface for attacks is minimal, but it's good to have this mindset for any interactive features.

-   **Continuous security practices:** Set up automated security monitoring. For instance, GitHub has Dependabot alerts -- ensure they're enabled for the repo so you get notified of future vulnerabilities in dependencies. After deployment, monitor the site occasionally (or use a service) for common security issues like if any resource is being loaded from an unintended domain (could indicate compromise) or if any unexpected content appears. These are proactive measures for long-term health of the site. Also, because this is a marketing site, consider backups/versioning: keep the repo backed up (which it is on GitHub) and possibly export the static site as a backup (Next.js can `next export` to HTML if ever needed as a fallback).

6\. Deployment on Vercel and Post-Launch
----------------------------------------

-   **Vercel deployment setup:** Deploy the application to **Vercel** for a smooth production release. Vercel is the recommended platform for Next.js apps, offering easy integration and a global CDN out of the box. If you haven't already, sign up for Vercel and link the GitHub repository. Vercel will automatically build and deploy the site on every push to the main branch. Alternatively, use the Vercel CLI: run `vercel` in the project root and follow the prompts to configure the project. Ensure that the production build command is set to `pnpm build` and that no extra configuration is needed (the template likely doesn't require any special build settings). Also double-check the environment variables in Vercel (in case you use any, set them in the dashboard before the first deploy).

-   **Perform final QA on the live site:** Once deployed, access the live site (the *.vercel.app domain initially, or your custom domain if configured). Do a thorough test run on this live instance. Sometimes differences in environment (like Node version, minor OS differences, or environment variables on Vercel) can cause unexpected issues, so it's important to validate the production site itself. Verify that all images are loading via Vercel's optimized paths, all links work (relative links should be fine, but if any absolute URLs were used, ensure they point to the correct domain). Check that dynamic interactions still behave (there should be no difference, but, for example, a tooltip might behave slightly differently in a production build). Open the developer console and look for any errors or warnings that didn't appear locally. If anything is found, fix it and deploy again. This step ensures that the user experience on the actual production URL is as polished as on your local test.

-   **Setup custom domain and SSL (if applicable):** If Zebra Design has its own domain (say, **zebradesign.com**), configure it in Vercel. In the Vercel dashboard, add the custom domain and follow the instructions to point the DNS records to Vercel. This usually involves adding CNAME records or A records. Vercel will provision an SSL certificate for the domain automatically (within minutes, typically). After setting this up, test the site on the custom domain with https:// to ensure the certificate is working (the browser should show it's secure). Having a custom domain will make the site look professional upon launch.

-   **Enable analytics and monitoring:** With the site live, consider enabling Vercel Analytics (which can give you insights into traffic and performance metrics without needing cookies or client-side scripts). If more detailed analytics are required, integrate a tool like Google Analytics or Plausible via a Next.js `<Script>` tag or a small snippet, being mindful of GDPR/cookie law compliance if users from various regions will visit. Additionally, set up monitoring alerts -- for example, Vercel can notify you if a deployment fails. You might also want uptime monitoring (there are free services that ping the site to ensure it's up). While Vercel's infrastructure is robust, it's good to know if your site ever goes down.

-   **Post-launch SEO check:** After deployment, run the site through an SEO analyzer or Google's Search Console (you can use the URL inspection tool once the site is live). Ensure that the meta tags are correct and that the site is indexable. Create a **sitemap.xml** if not already done (Next.js can auto-generate one via plugins or you can hand-craft a simple one given it's a one-page site plus pricing page). Submit the sitemap to Google Search Console to encourage quick indexing. Also test the social media preview by sharing the link on a platform (or using an Open Graph viewer) to confirm that the OG image, title, and description are pulling through properly from your meta tags. This is part of the polish in a production launch, making sure the site not only works well but also presents well on search engines and social platforms.

-   **Final commit and documentation:** Merge or commit all final changes into the main branch with a descriptive commit message (e.g., "üèÅ Final responsive tweaks, accessibility fixes, and production prep for launch"). Tag this commit as a release (perhaps `v1.0` for the site) so you have a snapshot of the launch version. It's wise to add a brief note in the README about how to run the project in production, and any environment vars needed, so future maintainers or your future self have a reference. Since this project has a `documentation` folder with planning notes, you might also update it with a "Launch Checklist Completed on [Date]" note or create a new doc summarizing the launch. Good documentation is part of best practices, ensuring that all the hard work is recorded.

‚úÖ Final Launch Checklist
------------------------

-   **Code cleaned:** All template code and references have been removed or replaced; the codebase reflects only what the Zebra Design site needs (no dead sections or unused files).

-   **Responsive & tested:** The site is fully responsive (mobile, tablet, desktop) and all interactive components (accordions, toggles, tooltips) work correctly on both touch and mouse/keyboard. Tested on major browsers and devices with consistent results.

-   **No build errors:** The production build (`pnpm build`) completes without errors or warnings. The deployed site shows no console errors. All imports are used, and all required assets are loading.

-   **Accessibility passes:** Keyboard navigation is smooth, focus states are visible, and screen-reader essentials (aria labels, roles, alt text) are in place. Text contrast meets guidelines, ensuring content is readable by all.

-   **Performance optimized:** Images are optimized (using Next Image and proper sizing), no obvious bottlenecks in Lighthouse metrics, and unnecessary scripts have been pruned. The site is fast and lightweight, leveraging Next.js optimizations and Vercel's CDN.

-   **Secure and up-to-date:** Dependencies are updated with no known vulnerabilities reported. No sensitive data in the repo or client-side code. Next.js default headers trimmed for security. The site is served over HTTPS with appropriate security headers.

-   **Deployed and monitored:** The site is live on Vercel (with a custom domain if required). Post-deployment tests are completed, and monitoring/analytics are set up for ongoing insights. We're ready to launch confidently, knowing we followed best practices to make the site production-ready.